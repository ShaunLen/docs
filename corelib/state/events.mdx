---
title: "Events"
icon: "bolt"
description: "Type-safe event dispatching for decoupled communication"
---

<Info>
The Event system enables type-safe, decoupled communication between game systems.
</Info>

---

## Defining events

Events are simple structs or classes:

```csharp
// Simple event
public struct PlayerJoinedEvent
{
    public Player Player;
}

// Event with more data
public struct DamageDealtEvent
{
    public Player Attacker;
    public Player Victim;
    public float Damage;
    public DamageType Type;
    public Vector3 HitPosition;
}

// Event with computed properties
public struct KillEvent
{
    public Player Killer;
    public Player Victim;
    public Weapon Weapon;

    public bool IsHeadshot => HitZone == HitZone.Head;
    public HitZone HitZone;
}
```

---

## Dispatching events

```csharp
// Dispatch an event
Events.Dispatch(new PlayerJoinedEvent
{
    Player = newPlayer
});

// Dispatch with shorthand
Events.Dispatch<RoundStartedEvent>();

// Conditional dispatch
if (wasHeadshot)
{
    Events.Dispatch(new HeadshotEvent { ... });
}
```

---

## Subscribing to events

### Basic subscription

```csharp
// Subscribe with method
Events.On<PlayerJoinedEvent>(OnPlayerJoined);

private void OnPlayerJoined(PlayerJoinedEvent e)
{
    Log.Info($"Player joined: {e.Player.Name}");
}

// Subscribe with lambda
Events.On<RoundStartedEvent>(e =>
{
    ResetScores();
    SpawnPlayers();
});
```

### Unsubscribing

```csharp
// Store the handler
private Action<DamageDealtEvent> _damageHandler;

protected override void OnStart()
{
    _damageHandler = OnDamageDealt;
    Events.On(_damageHandler);
}

protected override void OnDestroy()
{
    Events.Off(_damageHandler);
}
```

### Scoped subscriptions

```csharp
// Auto-unsubscribe when component destroyed
Events.On<KillEvent>(OnKill).Until(this);

// Auto-unsubscribe after one call
Events.Once<MatchEndEvent>(OnMatchEnd);

// Auto-unsubscribe with cancellation token
Events.On<UpdateEvent>(OnUpdate).Until(cancellationToken);
```

---

## Handler priority

Control execution order:

```csharp
// Higher priority runs first
Events.On<DamageDealtEvent>(OnDamageEarly, priority: 100);
Events.On<DamageDealtEvent>(OnDamageNormal, priority: 0);
Events.On<DamageDealtEvent>(OnDamageLate, priority: -100);
```

| Priority | Use case |
|----------|----------|
| 100+ | Modification/cancellation |
| 0 | Normal handling |
| -100 | Cleanup/logging |

---

## Event filtering

Subscribe with conditions:

```csharp
// Only local player kills
Events.On<KillEvent>(OnLocalKill)
    .Where(e => e.Killer == Local.Pawn);

// Only headshots
Events.On<DamageDealtEvent>(OnHeadshot)
    .Where(e => e.HitZone == HitZone.Head);

// Combined filters
Events.On<KillEvent>(OnTeamKill)
    .Where(e => e.Killer.Team == e.Victim.Team)
    .Where(e => e.Killer != e.Victim);
```

---

## Cancellable events

Events that can be prevented:

```csharp
public class DamageEvent : ICancellableEvent
{
    public Player Target;
    public float Damage;

    public bool IsCancelled { get; set; }
    public string CancelReason { get; set; }
}

// Subscriber can cancel
Events.On<DamageEvent>(e =>
{
    if (e.Target.HasShield)
    {
        e.IsCancelled = true;
        e.CancelReason = "Blocked by shield";
    }
}, priority: 100); // High priority to run first

// Dispatcher checks cancellation
public void DealDamage(Player target, float amount)
{
    var evt = new DamageEvent { Target = target, Damage = amount };
    Events.Dispatch(evt);

    if (!evt.IsCancelled)
    {
        target.Health -= evt.Damage;
    }
}
```

---

## Network events

### Server-to-client events

```csharp
// Server dispatches
[ServerOnly]
public void AnnounceWinner(Team team)
{
    Events.DispatchToAll(new MatchWonEvent { Winner = team });
}

// Client receives
Events.On<MatchWonEvent>(e =>
{
    ShowVictoryScreen(e.Winner);
});
```

### Client-to-server events

```csharp
// Client requests
Events.DispatchToServer(new SpawnRequestEvent
{
    SpawnPoint = selectedSpawn
});

// Server handles
[ServerOnly]
Events.On<SpawnRequestEvent>((e, sender) =>
{
    if (CanSpawn(sender))
    {
        SpawnPlayer(sender, e.SpawnPoint);
    }
});
```

---

## Event channels

Separate event streams:

```csharp
// Create channels
var uiChannel = Events.CreateChannel("ui");
var gameplayChannel = Events.CreateChannel("gameplay");

// Subscribe to channel
uiChannel.On<ButtonClickedEvent>(OnButtonClicked);

// Dispatch to channel
uiChannel.Dispatch(new ButtonClickedEvent { ... });
```

---

## Common event patterns

### Request/Response

```csharp
// Request
public struct CanPickupRequest : IRequestEvent<bool>
{
    public Player Player;
    public Item Item;
}

// Usage
var canPickup = Events.Request(new CanPickupRequest
{
    Player = player,
    Item = item
});

// Handler
Events.OnRequest<CanPickupRequest, bool>(req =>
{
    return req.Player.Inventory.HasSpace;
});
```

### Aggregation

```csharp
// Collect responses from multiple handlers
public struct DamageModifierEvent
{
    public float BaseDamage;
    public List<float> Modifiers;

    public float FinalDamage => BaseDamage * Modifiers.Aggregate(1f, (a, b) => a * b);
}

// Multiple handlers add modifiers
Events.On<DamageModifierEvent>(e => e.Modifiers.Add(1.5f)); // +50%
Events.On<DamageModifierEvent>(e => e.Modifiers.Add(0.8f)); // -20%
```

---

## Best practices

<CardGroup cols={2}>
  <Card title="Use structs" icon="cube">
    Events should be structs for performance
  </Card>
  <Card title="Keep events focused" icon="bullseye">
    One event per concept, not kitchen-sink events
  </Card>
  <Card title="Unsubscribe always" icon="link-slash">
    Use `.Until()` or manual unsubscription
  </Card>
  <Card title="Avoid cycles" icon="rotate">
    Events shouldn't dispatch events in response
  </Card>
</CardGroup>

<Warning>
Never store event data long-term â€” events are transient notifications.
</Warning>

---

## Related pages

<CardGroup cols={2}>
  <Card title="Shared State" icon="database" href="/corelib/state/shared-state">
    State that triggers events
  </Card>
  <Card title="Patterns" icon="shapes" href="/corelib/state/patterns">
    Common event patterns
  </Card>
</CardGroup>
