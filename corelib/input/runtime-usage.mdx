---
title: "Input Runtime Usage"
icon: "code"
description: "Using the Enhanced Input system in gameplay code"
---

<Info>
This page covers how to use the Enhanced Input system in your runtime code.
</Info>

---

## Querying input

### Digital actions

```csharp
// Just pressed this frame
if (InputSystem.IsActionPressed("jump"))
{
    PerformJump();
}

// Currently held down
if (InputSystem.IsActionHeld("fire"))
{
    ContinueFiring();
}

// Just released this frame
if (InputSystem.IsActionReleased("aim"))
{
    StopAiming();
}
```

### Axis actions

```csharp
// Single axis (returns float)
float throttle = InputSystem.GetAxis1D("throttle");
ApplyThrottle(throttle);

// Two-axis (returns Vector2)
Vector2 moveInput = InputSystem.GetAxis2D("move");
ApplyMovement(moveInput);

// Look input (commonly mouse/stick)
Vector2 lookDelta = InputSystem.GetAxis2D("look");
ApplyRotation(lookDelta);
```

---

## Context management

### Setting the active context

```csharp
// Set base context (clears stack)
InputSystem.SetActiveContext("gameplay");

// Push context onto stack
InputSystem.PushContext("inventory");

// Pop context from stack
InputSystem.PopContext();

// Get current context
string current = InputSystem.ActiveContext;
```

### Common patterns

<Tabs>
  <Tab title="Menu toggle">
    ```csharp
    public class MenuController : Component
    {
        private bool _menuOpen = false;

        protected override void OnUpdate()
        {
            if (InputSystem.IsActionPressed("toggle_menu"))
            {
                _menuOpen = !_menuOpen;

                if (_menuOpen)
                {
                    InputSystem.PushContext("menu");
                    ShowMenu();
                }
                else
                {
                    InputSystem.PopContext();
                    HideMenu();
                }
            }
        }
    }
    ```
  </Tab>
  <Tab title="Vehicle entry">
    ```csharp
    public class VehicleController : Component
    {
        public void EnterVehicle(Player player)
        {
            // Switch to vehicle controls
            InputSystem.PushContext("vehicle");
            player.State = PlayerState.InVehicle;
        }

        public void ExitVehicle(Player player)
        {
            // Return to normal controls
            InputSystem.PopContext();
            player.State = PlayerState.OnFoot;
        }
    }
    ```
  </Tab>
  <Tab title="Dialogue">
    ```csharp
    public class DialogueSystem : Component
    {
        public void StartDialogue(Dialogue dialogue)
        {
            // Block gameplay input during dialogue
            InputSystem.PushContext("dialogue");
            ShowDialogueUI(dialogue);
        }

        public void EndDialogue()
        {
            InputSystem.PopContext();
            HideDialogueUI();
        }

        protected override void OnUpdate()
        {
            if (InputSystem.IsActionPressed("dialogue_advance"))
            {
                AdvanceDialogue();
            }
        }
    }
    ```
  </Tab>
</Tabs>

---

## Action state details

### Checking action existence

```csharp
// Check if action exists before using
if (InputSystem.HasAction("special_ability"))
{
    if (InputSystem.IsActionPressed("special_ability"))
    {
        UseSpecialAbility();
    }
}
```

### Getting raw values

```csharp
// Get the raw action value regardless of type
InputActionValue value = InputSystem.GetActionValue("move");

// Check the type
if (value.Type == InputActionType.Axis2D)
{
    Vector2 move = value.AsVector2();
}
```

### Action info

```csharp
// Get information about an action
InputActionInfo info = InputSystem.GetActionInfo("jump");

Log.Info($"Action: {info.DisplayName}");
Log.Info($"Type: {info.Type}");
Log.Info($"Current bindings: {info.Bindings.Count}");
```

---

## Input events

Subscribe to input events for reactive patterns:

```csharp
public class InputEventHandler : Component
{
    protected override void OnStart()
    {
        // Subscribe to specific action
        InputSystem.OnActionPressed("jump", OnJumpPressed);
        InputSystem.OnActionReleased("jump", OnJumpReleased);

        // Subscribe to any input
        InputSystem.OnAnyActionPressed += OnAnyAction;

        // Subscribe to context changes
        InputSystem.OnContextChanged += OnContextChanged;
    }

    private void OnJumpPressed()
    {
        StartJumpAnimation();
    }

    private void OnJumpReleased()
    {
        EndJumpAnimation();
    }

    private void OnAnyAction(string actionId)
    {
        Log.Debug($"Action pressed: {actionId}");
    }

    private void OnContextChanged(string oldContext, string newContext)
    {
        Log.Info($"Context changed: {oldContext} -> {newContext}");
    }

    protected override void OnDestroy()
    {
        // Unsubscribe to prevent leaks
        InputSystem.OnActionPressed("jump", OnJumpPressed);
        InputSystem.OnAnyActionPressed -= OnAnyAction;
    }
}
```

---

## Input consumption

Prevent input from propagating to other systems:

```csharp
public class UIController : Component
{
    protected override void OnUpdate()
    {
        if (InputSystem.IsActionPressed("confirm"))
        {
            // Handle the input
            ConfirmSelection();

            // Consume so gameplay doesn't also respond
            InputSystem.ConsumeAction("confirm");
        }
    }
}

public class PlayerController : Component
{
    protected override void OnUpdate()
    {
        // This won't trigger if UI consumed the action
        if (InputSystem.IsActionPressed("confirm"))
        {
            Interact();
        }
    }
}
```

---

## Input buffering

Buffer inputs for responsive controls:

```csharp
public class CombatController : Component
{
    private float _jumpBufferTime = 0.1f;
    private float _lastJumpPress = -1f;

    protected override void OnUpdate()
    {
        // Record jump press time
        if (InputSystem.IsActionPressed("jump"))
        {
            _lastJumpPress = Time.Now;
        }

        // Check buffered input
        if (CanJump() && WasJumpBuffered())
        {
            PerformJump();
            _lastJumpPress = -1f; // Clear buffer
        }
    }

    private bool WasJumpBuffered()
    {
        return _lastJumpPress > 0 &&
               Time.Now - _lastJumpPress < _jumpBufferTime;
    }
}
```

---

## Device-specific handling

```csharp
public class InputHints : Component
{
    protected override void OnUpdate()
    {
        // Show appropriate hints based on last used device
        var lastDevice = InputSystem.LastActiveDevice;

        switch (lastDevice)
        {
            case InputDevice.Keyboard:
                ShowKeyboardHints();
                break;
            case InputDevice.Gamepad:
                ShowGamepadHints();
                break;
        }
    }

    private void ShowKeyboardHints()
    {
        // Get the current binding for display
        var jumpBinding = InputSystem.GetPrimaryBinding("jump");
        _jumpHint.Text = $"Press {jumpBinding.DisplayName} to jump";
    }
}
```

---

## Best practices

<CardGroup cols={2}>
  <Card title="Query in OnUpdate" icon="check" color="#16A34A">
    Input queries should happen in update loops, not event handlers
  </Card>
  <Card title="Use action names" icon="check" color="#16A34A">
    Never hardcode key checks â€” always use action IDs
  </Card>
  <Card title="Clean up subscriptions" icon="check" color="#16A34A">
    Unsubscribe from events when destroyed
  </Card>
  <Card title="Handle missing actions" icon="check" color="#16A34A">
    Check `HasAction()` for optional features
  </Card>
</CardGroup>

<Warning>
**Avoid:**
- Querying input in constructors
- Mixing raw input APIs with Enhanced Input
- Forgetting to pop contexts
</Warning>

---

## Complete example

```csharp
public class PlayerController : Component
{
    [Property] public float MoveSpeed { get; set; } = 5f;
    [Property] public float JumpForce { get; set; } = 10f;

    private CharacterController _controller;
    private bool _isGrounded;

    protected override void OnStart()
    {
        _controller = Components.Get<CharacterController>();

        // Set initial context
        InputSystem.SetActiveContext("gameplay");
    }

    protected override void OnUpdate()
    {
        HandleMovement();
        HandleJump();
        HandleInteraction();
    }

    private void HandleMovement()
    {
        var moveInput = InputSystem.GetAxis2D("move");
        var moveDir = new Vector3(moveInput.x, 0, moveInput.y);

        _controller.Move(moveDir * MoveSpeed * Time.Delta);
    }

    private void HandleJump()
    {
        if (_isGrounded && InputSystem.IsActionPressed("jump"))
        {
            _controller.Velocity = Vector3.Up * JumpForce;
        }
    }

    private void HandleInteraction()
    {
        if (InputSystem.IsActionPressed("interact"))
        {
            TryInteract();
        }
    }
}
```

---

## Related pages

<CardGroup cols={2}>
  <Card title="Rebinding" icon="keyboard" href="/corelib/input/rebinding">
    Implementing player rebinding
  </Card>
  <Card title="Best Practices" icon="star" href="/corelib/input/best-practices">
    Recommended patterns
  </Card>
</CardGroup>
