---
title: "Code Style"
icon: "code"
description: "Code style and readability conventions used at Northbound"
---

<Info>
These guidelines describe the **expected code style** across Northbound projects. Consistency and readability matter more than individual preference.
</Info>

---

## General principles

<CardGroup cols={3}>
  <Card title="Readability first" icon="eye">
    Code is read more often than written
  </Card>
  <Card title="Consistency wins" icon="equals">
    Match existing patterns over personal style
  </Card>
  <Card title="Clarity over cleverness" icon="lightbulb">
    Obvious is better than elegant
  </Card>
</CardGroup>

<Note>
Modern C# features are welcome when they **improve** readability, not when they obscure intent.
</Note>

---

## Naming and file organization

<Note>
For comprehensive naming rules, file organization, and folder structure conventions, see the dedicated reference pages below.
</Note>

<CardGroup cols={2}>
  <Card title="Naming Conventions" icon="tag" href="/handbook/naming">
    Detailed rules for naming types, methods, variables, files, and more
  </Card>
  <Card title="Folder Structure" icon="folder-tree" href="/handbook/folder-structure">
    Project organization and namespace mapping
  </Card>
</CardGroup>

---

## `var` usage

<Tip>
We prefer `var` for local variables when the type is obvious.
</Tip>

```csharp
// Good: Type is obvious from the right side
var player = GetPlayer();
var weapons = new List<Weapon>();
var config = LoadConfiguration();

// Avoid var: Type is not immediately clear
InputContext context = GetCurrentContext(); // What does this return?
```

Avoid `var` only when:
- The inferred type is unclear
- It harms readability
- The type itself carries important meaning

---

## Modern C# syntax

<Tabs>
  <Tab title="Acceptable">
    ```csharp
    // Expression-bodied members
    public bool IsValid => _data != null && _data.IsComplete;

    // Pattern matching
    if (target is Player { IsAlive: true } player)
        player.TakeDamage(damage);

    // Switch expressions
    var icon = state switch
    {
        State.Active => "active.png",
        State.Disabled => "disabled.png",
        _ => "default.png"
    };
    ```
  </Tab>
  <Tab title="Avoid">
    ```csharp
    // Obscured control flow
    var result = condition ? nested ? a : b : c;

    // Over-nested pattern matching
    if (obj is { Prop: { Inner: { Value: > 10 } } })

    // Complex LINQ in one line
    var x = items.Where(i => i.Active).Select(i => i.Value).GroupBy(v => v.Type).ToDictionary(g => g.Key, g => g.Sum());
    ```
  </Tab>
</Tabs>

<Note>
Use shorthand when it makes code clearer. Avoid it when it requires mental parsing to understand.
</Note>

---

## LINQ usage

<CardGroup cols={2}>
  <Card title="Good uses" icon="check" color="#16A34A">
    - Making intent clearer
    - Simple transformations
    - Filtering and projection
    - Cold paths
  </Card>
  <Card title="Be careful with" icon="warning" color="#EAB308">
    - Complex chained queries
    - Hot paths (allocations)
    - When a loop is clearer
    - Multiple enumerations
  </Card>
</CardGroup>

<Warning>
Readability should not be sacrificed just to use LINQ. Sometimes a `foreach` is better.
</Warning>

---

## File and type organisation

| Rule | Example |
|------|---------|
| One public type per file | `Player.cs` contains `public class Player` |
| File name matches type | `InteractionProvider.cs` for `InteractionProvider` |
| Related private types stay close | Nested classes or same file |

<Note>
Large files are acceptable if they remain cohesive and readable.
</Note>

---

## Method structure

<Steps>
  <Step title="Do one thing">
    Methods should operate at one level of abstraction
  </Step>
  <Step title="Keep it focused">
    Prefer small, single-purpose methods
  </Step>
  <Step title="Use early returns">
    Guard clauses reduce nesting and clarify preconditions
  </Step>
</Steps>

```csharp
// Good: Early returns and single purpose
public bool TryGetPlayer(int id, out Player player)
{
    player = null;

    if (!_players.TryGetValue(id, out var found))
        return false;

    if (!found.IsActive)
        return false;

    player = found;
    return true;
}
```

---

## Comments and documentation

<Tabs>
  <Tab title="Code comments">
    - Explain **why**, not **what**
    - Avoid restating the code
    - Remove outdated comments aggressively

    ```csharp
    // Bad: Restates the code
    // Increment counter by one
    counter++;

    // Good: Explains why
    // Skip validation in editor to speed up iteration
    if (Application.isEditor)
        return;
    ```
  </Tab>
  <Tab title="XML documentation">
    Required for public APIs in shared libraries.

    ```csharp
    /// <summary>
    /// Attempts to find an interaction target within range of the player.
    /// </summary>
    /// <param name="player">The player performing the search.</param>
    /// <param name="maxDistance">Maximum search distance in units.</param>
    /// <returns>The nearest valid target, or null if none found.</returns>
    public IInteractable FindTarget(Player player, float maxDistance)
    ```
  </Tab>
</Tabs>

---

## Null handling

<Warning>
Nullability should be handled explicitly and intentionally.
</Warning>

| Practice | Description |
|----------|-------------|
| Avoid ambiguous null states | If something can be null, make it obvious |
| Validate inputs early | Check at API boundaries |
| Make expectations clear | Naming and documentation should indicate nullability |

```csharp
// Clear nullable intent
public Player? FindPlayer(int id) // May return null
public Player GetPlayer(int id)   // Never returns null (throws if not found)
```

---

## `#region` usage

<Tabs>
  <Tab title="Editor code">
    Acceptable in editor code where large inspector or tooling classes may be unavoidable.

    ```csharp
    #region Inspector Drawing
    // Large blocks of editor UI code
    #endregion
    ```
  </Tab>
  <Tab title="Runtime code">
    Generally avoid. Needing regions usually means the class is doing too much.

    <Warning>
    If you need regions to navigate a runtime class, consider splitting it.
    </Warning>
  </Tab>
</Tabs>

---

## Namespaces and structure

<Tip>
Namespaces should **always match folder structure**.
</Tip>

```
CoreLib/
├── Input/
│   ├── InputContext.cs      // namespace CoreLib.Input
│   └── InputBinding.cs      // namespace CoreLib.Input
├── Interactions/
│   └── InteractionProvider.cs  // namespace CoreLib.Interactions
```

This consistency makes navigation and discovery significantly easier.

---

## Editor vs runtime code

<CardGroup cols={2}>
  <Card title="Editor code" icon="window">
    - Lives in editor assemblies
    - Uses editor namespaces
    - Can reference runtime code
  </Card>
  <Card title="Runtime code" icon="play">
    - Lives in runtime assemblies
    - Never depends on editor APIs
    - Separation obvious from structure
  </Card>
</CardGroup>

<Warning>
Leaks between editor and runtime code should be treated as design issues.
</Warning>

---

## Summary

Good code style:

<CardGroup cols={3}>
  <Card title="Communicates" icon="comments">
    Intent is clear to readers
  </Card>
  <Card title="Reduces load" icon="brain">
    Easy to understand quickly
  </Card>
  <Card title="Scales" icon="arrow-up-right-dots">
    Works for teams and large projects
  </Card>
</CardGroup>

<Note>
These guidelines exist to support those goals, not to constrain reasonable judgment.
</Note>

---

## Related pages

<CardGroup cols={2}>
  <Card title="Architecture Conventions" icon="sitemap" href="/handbook/architecture-conventions">
    How we structure systems and projects
  </Card>
  <Card title="Terminology" icon="book" href="/handbook/terminology">
    Standard terms and definitions
  </Card>
</CardGroup>
